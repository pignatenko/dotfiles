
" Easy Align Text By Delimeter
Plug 'junegunn/vim-easy-align'

  " For visual mode (e.g. vip<Enter>)
  vmap <Enter>   <Plug>(EasyAlign)

  " For normal mode, with Vim movement (e.g. <Leader>aip)
  nmap <Leader>a <Plug>(EasyAlign)

" Easy Motion Movements
" Needs example.
Plug 'easymotion/vim-easymotion'

" Show the register when using " or @
Plug 'junegunn/vim-peekaboo'
let g:peekaboo_window = 'call CreateRightSideFloatingWindow()'

" */# highlights without moving curosr, highlight removed moving cursor
" Plug 'junegunn/vim-slash'

" File explorer sidebar



  " Just show the side bar
  map <Leader>fl :CHADopen<cr>
  noremap <Leader>fl :CHADopen<cr>

  " Find current file
  map <Leader>ff :CHADopen<cr>
  noremap <Leader>ff :CHADopen<cr>

" Fuzzy finder / (move to denite?)

  map <Leader>fs :FZF<cr>
  noremap <Leader>fs :FZF<cr>

  map <Leader>ts :Tags<cr>
  noremap <Leader>ts :Tags<cr>

  map <Leader>bs :Buffers<cr>
  noremap <Leader>bs :Buffers<cr>

" Plug 'w0rp/ale'
" let g:ale_linters = {}
" let g:ale_lint_delay = 500

" Present in kitty correctly
if !empty($KITTY_WINDOW_ID) 
  highlight ALEWarning cterm=undercurl gui=undercurl guisp=#81a2be
  highlight ALEError cterm=undercurl gui=undercurl guisp=#cc6666
endif



" Plug 'ludovicchabant/vim-gutentags'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-projectionist'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-rails'

augroup vimrails
  au!
  autocmd FileType ruby map <Leader>gt :execute "e " . fnameescape(rails#buffer().alternate())<cr>
  autocmd FileType ruby noremap <Leader>gt :execute "e " . fnameescape(rails#buffer().alternate())<cr>
augroup end



" Allows you to use . to repeat most things
"
Plug 'tpope/vim-repeat'

" Allows you to add/change surrounding syntax
" try yss" css' -- prefix is ys/cs <motion>
Plug 'tpope/vim-surround'

" Allows you to comment things out easily
" try: gcc -- generally gc <motion>
Plug 'tpope/vim-commentary'



" Plug 'neoclide/coc.nvim', {'branch': 'release'}
" let g:coc_node_path = substitute(system('which node'), '\n', '', 'g')

" inoremap <silent><expr> <c-x><c-u> coc#refresh()
" inoremap <silent><expr> <c-x><c-o> coc#refresh()


" " Use `[c` and `]c` to navigate diagnostics
" nmap <silent> [c <Plug>(coc-diagnostic-prev)
" nmap <silent> ]c <Plug>(coc-diagnostic-next)

" nmap <silent> <leader>gd <Plug>(coc-definition)
" nmap <silent> <leader>gy <Plug>(coc-type-definition)
" nmap <silent> <leader>gi <Plug>(coc-implementation)
" nmap <silent> <leader>gr <Plug>(coc-references)
" nmap <silent> <leader>cn <Plug>(coc-rename)

" xmap <leader>gq  <Plug>(coc-format-selected)
" nmap <leader>gq  <Plug>(coc-format-selected)

" nmap <leader>qf  <Plug>(coc-fix-current)

" nnoremap <silent> <leader>ld  :<C-u>CocList diagnostics<cr>
" nnoremap <silent> <leader>so :<C-u>CocList outline<cr>
" nnoremap <silent> <leader>ss :<C-u>CocList -I symbols<cr>





" Check for lang servers.
" Ruby - solargraph
" JS - javascript-typescript-langserver


" Salt
Plug 'saltstack/salt-vim'


" SQL
Plug 'vim-scripts/dbext.vim', { 'on': ['DBExecVisualSQL', 'DBExecVisualSQLTopX', 'DBExecSQLUnderCursor', 'DBExecSQLUnderCursorTopX', 'DBExecSQL', 'DBExecRangeSQL', 'DBSelectFromTable', 'DBSelectFromTableWithWhere', 'DBSelectFromTableAskName', 'DBSelectFromTableTopX', 'DBDescribeTable', 'DBDescribeTableAskName', 'DBDescribeProcedure', 'DBDescribeProcedureAskName', 'DBPromptForBufferParameters', 'DBListColumn', 'DBListTable', 'DBListProcedure', 'DBListView', 'DBOrientationToggle', 'DBHistory', 'DBGetStoredProcBody', 'DBGetStoredProcTemplate']}

" Javascript
Plug 'pangloss/vim-javascript', { 'for': [ 'javascript' ] }

" Typescript
"
Plug 'leafgarland/typescript-vim'

" Creative writing concentration.
Plug 'junegunn/goyo.vim', { 'on': ['Goyo', 'GoyoEnter', 'GoyoLeave'] }
Plug 'junegunn/limelight.vim', { 'on': ['Limelight'] }


let g:polyglot_disabled = ['csv']
Plug 'sheerun/vim-polyglot'



Plug 'janko/vim-test'
let test#strategy = 'neovim'
let test#javascript#jest#executable = 'yarn jest'
nmap <silent> <leader>tn :TestNearest<CR>
nmap <silent> <leader>tf :TestFile<CR>
nmap <silent> <leader>ts :TestSuite<CR>
nmap <silent> <leader>tl :TestLast<CR>
nmap <silent> <leader>tv :TestVisit<CR>


Plug 'bumaociyuan/vim-swift'
Plug 'plasticboy/vim-markdown'
Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() } }

let g:mkdp_preview_options = {
    \ 'mkit': {},
    \ 'katex': {},
    \ 'uml': {
       \ 'server': system("echo http://`docker-machine inspect | jq -r .Driver.IPAddress`:37176")
       \ },
    \ 'maid': {
      \ 'securityLevel': 'loose'
      \},
    \ 'disable_sync_scroll': 0,
    \ 'sync_scroll_type': 'middle',
    \ 'hide_yaml_meta': 1,
    \ 'disable_filename': 0,
    \ 'sequence_diagrams': {}
    \ }


let g:mkdp_markdown_css = expand('~/.config/nvim/markdown-preview/markdown.css')
" Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }




" let g:deoplete#enable_at_startup = 1
" let g:deoplete#enable_smart_case = 1
" let g:deoplete#disable_auto_complete = 1
" inoremap <expr> <C-X><C-O> deoplete#mappings#manual_complete()
Plug 'gyim/vim-boxdraw'


Plug 'SirVer/ultisnips'
let g:UltiSnipsExpandTrigger="<c-x><c-m>"
let g:UltiSnipsListSnippets="<c-l>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-k>"
let g:UltiSnipsEditSplit="vertical"
let g:UltiSnipsSnippetDirectories=["macros"]



Plug 'tpope/vim-fugitive'
Plug 'mechatroner/rainbow_csv'


Plug 'neovim/nvim-lspconfig'
Plug 'williamboman/nvim-lsp-installer', { 'branch': 'main' }

Plug 'ms-jpq/coq_nvim', {'branch': 'coq'}

Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
Plug 'nvim-treesitter/nvim-treesitter-textobjects'

Plug 'ggandor/lightspeed.nvim', { 'branch': 'main' }
" Plug 'ms-jpq/coq_nvim', {'branch': 'coq'}

" Plug 'lbrayner/vim-rzip'

Plug 'akinsho/toggleterm.nvim'

set diffopt+=vertical
call plug#end()

lua << EOF

  local lsp_installer = require("nvim-lsp-installer")

  lsp_installer.settings({
      ui = {
          icons = {
              server_installed = "✓",
              server_pending = "➜",
              server_uninstalled = "✗"
          }
      }
  })

  lsp_installer.on_server_ready(function(server)
      local opts = {}

      if server.name == 'eslint' then
        opts.packageManager = 'yarn'
      end
      -- (optional) Customize the options passed to the server
      -- if server.name == "tsserver" then
      --     opts.root_dir = function() ... end
      -- end

      -- This setup() function is exactly the same as lspconfig's setup function.
      -- Refer to https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md
      server:setup(opts)
end)
EOF


lua <<EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = "maintained",     -- one of "all", "language", or a list of languages
  ignore_install = { "haskell", "cpp" },
  highlight = {
    enable = true,              -- false will disable the whole extension
  },
}
EOF



lua <<EOF
local ts_utils = require 'nvim-treesitter.ts_utils'
require'nvim-treesitter.configs'.setup {
  textobjects = {
    select = {
      enable = true,

      -- Automatically jump forward to textobj, similar to targets.vim 
      lookahead = true,

      keymaps = {
        -- You can use the capture groups defined in textobjects.scm
        ["af"] = "@function.outer",
        ["if"] = "@function.inner",
        ["ab"] = "@block.outer",
        ["ib"] = "@block.inner",
        ["as"] = "@statement.outer",
        ["is"] = "@statement.inner",
        ["ap"] = "@parameter.outer",
        ["ip"] = "@parameter.inner",
        ["ac"] = "@class.outer",
        ["ic"] = "@class.inner",

        -- Or you can define your own textobjects like this
        ["iF"] = {
          python = "(function_definition) @function",
          javascript = "(function_definition) @function",
          typescript = "(function_definition) @function",
          cpp = "(function_definition) @function",
          c = "(function_definition) @function",
          java = "(method_declaration) @function",
        },
      },
    },
    swap = {
      enable = true,
      swap_next = {
        ["<leader>sp"] = "@parameter.inner",
        ["<leader>sf"] = "@function.outer",
        ["<leader>sc"] = "@class.outer",
      },
      swap_previous = {
        ["<leader>Sp"] = "@parameter.inner",
        ["<leader>Sf"] = "@function.outer",
        ["<leader>Sc"] = "@class.outer",
      },
    },
    move = {
      enable = true,
      set_jumps = true, -- whether to set jumps in the jumplist
      goto_next_start = {
        ["<leader>jb"] = "@block.outer",
        ["<leader>js"] = "@statement.outer",
        ["<leader>jf"] = "@function.outer",
        ["<leader>jc"] = "@class.outer",
        ["<leader>jp"] = "@parameter.inner",
      },
      goto_next_end = {
        ["<leader>jS"] = "@statement.outer",
        ["<leader>jB"] = "@block.outer",
        ["<leader>jF"] = "@function.outer",
        ["<leader>jC"] = "@class.outer",
        ["<leader>jP"] = "@parameter.inner",
      },
      goto_previous_start = {
        ["<leader>Js"] = "@statement.outer",
        ["<leader>Jb"] = "@block.outer",
        ["<leader>Jf"] = "@function.outer",
        ["<leader>Jc"] = "@class.outer",
        ["<leader>Jp"] = "@parameter.inner",
      },
      goto_previous_end = {
        ["<leader>JS"] = "@statement.outer",
        ["<leader>JB"] = "@block.outer",
        ["<leader>JF"] = "@function.outer",
        ["<leader>JC"] = "@class.outer",
        ["<leader>JP"] = "@parameter.inner",
      },
    },
    lsp_interop = {
      enable = true,
      border = 'none',
      peek_definition_code = {
        ["<leader>df"] = "@function.outer",
        ["<leader>dF"] = "@class.outer",
      },
    },
  },
}
EOF

lua << EOF
local nvim_lsp = require('lspconfig')

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  -- Enable completion triggered by <c-x><c-o>
  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings.
  local opts = { noremap=true, silent=true }

  -- See `:help vim.lsp.*` for documentation on any of the below functions
  buf_set_keymap('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  buf_set_keymap('n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
  buf_set_keymap('n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
  buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
  buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
  buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  buf_set_keymap('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  buf_set_keymap('n', '<space>ca', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
  buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  buf_set_keymap('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
  buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
  buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
  buf_set_keymap('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
  buf_set_keymap('n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)

end
EOF

lua << EOF
require("toggleterm").setup {
}
EOF

" function! RemapTerminalEscape()
"   if @% =~ '#FZF'
"     return
"   endif
" endfunction

augroup terminal
  au!
  autocmd TermEnter term://*toggleterm#* tnoremap <buffer> <Esc> <C-\><C-n>
augroup end

nnoremap <Leader>tt :ToggleTerm<cr>



